{"version":3,"sources":["/home/circleci/project/webpack/bootstrap","/home/circleci/project/node_modules/webpack/buildin/global.js","/home/circleci/project/packages/webviz-core/src/players/UserNodePlayer/nodeRuntimeWorker/index.js","/home/circleci/project/packages/webviz-core/src/players/UserNodePlayer/nodeRuntimeWorker/registry.js","/home/circleci/project/packages/webviz-core/src/util/Rpc.js","/home/circleci/project/packages/webviz-core/src/util/workers.js"],"names":["enumerable","get","getter","value","key","bind","module","Object","prototype","hasOwnProperty","call","object","property","g","this","Function","e","window","exports","inSharedWorker","Error","global","onconnect","port","ports","rpc","Rpc","receive","enforceFetchIsBlocked","registerNode","processMessage","start","nodeCallback","containsFuncDeclaration","args","arg","values","stringifyFuncsInObject","newArg","entries","getArgsToPrint","map","JSON","stringify","requireImplementation","id","projectCode","requestedFile","file","source","endsWith","sourceExports","require","reqId","nodeCode","userNodeLogs","userNodeDiagnostics","self","log","argsToPrint","join","push","nodeExports","default","error","toString","length","message","local","onmessage","postMessage","data","transfer","ev","MessageEvent","remote","terminate","constructor","channel","Map","topic","_pendingCallbacks","Promise","resolve","reject","handler","_receivers","then","result","_channel","transferrables","catch","err","name","stack","_onChannelMessage","send","_messageId","info","has","set","WorkerGlobalScope","SharedWorkerGlobalScope","fn","canFetch","fetch","async"],"mappings":"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","file":"nodeRuntimeWorker-99f4bc836ce7710b7136.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// @flow\n//\n//  Copyright (c) 2019-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\nimport { registerNode, processMessage } from \"webviz-core/src/players/UserNodePlayer/nodeRuntimeWorker/registry\";\nimport Rpc from \"webviz-core/src/util/Rpc\";\nimport { enforceFetchIsBlocked, inSharedWorker } from \"webviz-core/src/util/workers\";\n\nif (!inSharedWorker()) {\n  // In Chrome, web workers currently (as of March 2020) inherit their Content Security Policy from\n  // their associated page, ignoring any policy in the headers of their source file. SharedWorkers\n  // use the headers from their source files, though, and we use a CSP to prohibit node playground\n  // workers from making web requests (using enforceFetchIsBlocked, below.)\n  // TODO(steel): Change this back to a web worker if/when Chrome changes its behavior:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1012640\n  throw new Error(\"Not in a SharedWorker.\");\n}\n\nglobal.onconnect = (e) => {\n  const port = e.ports[0];\n  const rpc = new Rpc(port);\n  // Just check fetch is blocked on registration, don't slow down message processing.\n  rpc.receive(\"registerNode\", enforceFetchIsBlocked(registerNode));\n  rpc.receive(\"processMessage\", processMessage);\n  port.start();\n};\n","// @flow\n//\n//  Copyright (c) 2019-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\nimport type { ProcessMessageOutput, RegistrationOutput } from \"webviz-core/src/players/UserNodePlayer/types\";\n\n// Each node runtime worker runs one node at a time, hence why we have one\n// global declaration of 'nodeCallback'.\nlet nodeCallback: (message: {}) => void | {} = () => {};\n\nif (process.env.NODE_ENV === \"test\") {\n  // When in tests, clear out the callback between tests.\n  beforeEach(() => {\n    nodeCallback = () => {};\n  });\n}\n\nexport const containsFuncDeclaration = (args: any[]) => {\n  for (const arg of args) {\n    if (typeof arg === \"function\") {\n      return true;\n    } else if (arg != null && typeof arg === \"object\") {\n      for (const value of Object.values(arg)) {\n        if (containsFuncDeclaration([value])) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\nexport const stringifyFuncsInObject = (arg: any) => {\n  if (typeof arg === \"function\") {\n    return `${arg}`;\n  } else if (arg != null && typeof arg === \"object\") {\n    const newArg = { ...arg };\n    for (const [key, value] of Object.entries(arg)) {\n      newArg[key] = stringifyFuncsInObject(value);\n    }\n    return newArg;\n  }\n  return arg;\n};\n\nconst getArgsToPrint = (args: any[]) => {\n  return args.map(stringifyFuncsInObject).map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg));\n};\n\nconst requireImplementation = (id: string, projectCode: Map<string, string>) => {\n  const requestedFile = `${id}.js`;\n  for (const [file, source] of projectCode.entries()) {\n    if (file.endsWith(requestedFile)) {\n      const sourceExports = {};\n      const require = (reqId: string) => requireImplementation(reqId, projectCode);\n      // $FlowFixMe\n      new Function(\"exports\", \"require\", source)(sourceExports, require); /* eslint-disable-line no-new-func */\n      return sourceExports;\n    }\n  }\n  throw new Error(`User node required unknown module: '${id}'`);\n};\n\nexport const registerNode = ({\n  nodeCode,\n  projectCode,\n}: {\n  nodeCode: string,\n  projectCode: Map<string, string>,\n}): RegistrationOutput => {\n  const userNodeLogs = [];\n  const userNodeDiagnostics = [];\n  self.log = function(...args) {\n    // recursively check that args do not contain a function declaration\n    if (containsFuncDeclaration(args)) {\n      const argsToPrint = getArgsToPrint(args);\n      throw new Error(`Cannot invoke log() with a function argument (registerNode) - log(${argsToPrint.join(\", \")})`);\n    }\n    userNodeLogs.push(...args.map((value) => ({ source: \"registerNode\", value })));\n  };\n  // TODO: Blacklist global methods.\n  try {\n    const nodeExports = {};\n\n    const require = (id: string) => requireImplementation(id, projectCode);\n\n    // Using new Function in order to execute user-input text in Node Playground as code\n    // $FlowFixMe\n    new Function(\"exports\", \"require\", nodeCode)(nodeExports, require); /* eslint-disable-line no-new-func */\n    nodeCallback = nodeExports.default;\n    return {\n      error: null,\n      userNodeLogs,\n      userNodeDiagnostics,\n    };\n  } catch (e) {\n    const error = e.toString();\n    return {\n      error: error.length ? error : `Unknown error encountered registering this node.`,\n      userNodeLogs,\n      userNodeDiagnostics,\n    };\n  }\n};\n\nexport const processMessage = ({ message }: { message: {} }): ProcessMessageOutput => {\n  const userNodeLogs = [];\n  const userNodeDiagnostics = [];\n  self.log = function(...args) {\n    // recursively check that args do not contain a function declaration\n    if (containsFuncDeclaration(args)) {\n      const argsToPrint = getArgsToPrint(args);\n      throw new Error(`Cannot invoke log() with a function argument (processMessage) - log(${argsToPrint.join(\", \")})`);\n    }\n    userNodeLogs.push(...args.map((value) => ({ source: \"processMessage\", value })));\n  };\n  try {\n    const newMessage = nodeCallback(message);\n    return { message: newMessage, error: null, userNodeLogs, userNodeDiagnostics };\n  } catch (e) {\n    // TODO: Be able to map line numbers from errors.\n    const error = e.toString();\n    return {\n      message: null,\n      error: error.length ? error : \"Unknown error encountered running this node.\",\n      userNodeLogs,\n      userNodeDiagnostics,\n    };\n  }\n};\n","// @flow\n//\n//  Copyright (c) 2018-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n// this type mirrors the MessageChannel and MessagePort APIs which are available on\n// instances of web-workers and shared-workers respectively, as well as avaiable on\n// 'global' within them.\nexport interface Channel {\n  postMessage(data: any, transfer?: any[]): void;\n  onmessage: null | ((ev: MessageEvent) => mixed);\n}\n\n// Flow complains when some variables are declared with the above interface type, but\n// not when given this non-interface type...\nexport type ChannelImpl = {\n  postMessage(data: any, transfer?: any[]): void,\n  onmessage: null | ((ev: MessageEvent) => mixed),\n};\n\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n\n// helper function to create linked channels for testing\nexport function createLinkedChannels(): { local: Channel, remote: Channel } {\n  const local: ChannelImpl = {\n    onmessage: null,\n    postMessage(data: any, transfer?: Array<ArrayBuffer>) {\n      const ev = new MessageEvent(\"message\", { data });\n      // eslint-disable-next-line no-use-before-define\n      if (remote.onmessage) {\n        remote.onmessage(ev); // eslint-disable-line no-use-before-define\n      }\n    },\n    terminate: () => {},\n  };\n\n  const remote: ChannelImpl = {\n    onmessage: null,\n    postMessage(data: any, transfer?: Array<ArrayBuffer>) {\n      const ev = new MessageEvent(\"message\", { data });\n      if (local.onmessage) {\n        local.onmessage(ev);\n      }\n    },\n    terminate: () => {},\n  };\n  return { local, remote };\n}\n\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\nexport default class Rpc {\n  static transferrables = \"$$TRANSFERRABLES\";\n  _channel: Channel;\n  _messageId: number = 0;\n  _pendingCallbacks: { [number]: (any) => void } = {};\n  _receivers: Map<string, (any) => any> = new Map();\n\n  constructor(channel: Channel) {\n    this._channel = channel;\n    if (this._channel.onmessage) {\n      throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n    }\n    this._channel.onmessage = this._onChannelMessage;\n  }\n\n  _onChannelMessage = (ev: MessageEvent) => {\n    const { id, topic, data } = (ev.data: any);\n    if (topic === RESPONSE) {\n      this._pendingCallbacks[id](ev.data);\n      delete this._pendingCallbacks[id];\n      return;\n    }\n    // invoke the receive handler in a promise so if it throws synchronously we can reject\n    new Promise((resolve, reject) => {\n      const handler = this._receivers.get(topic);\n      if (!handler) {\n        throw new Error(`no receiver registered for ${topic}`);\n      }\n      // This works both when `handler` returns a value or a Promise.\n      resolve(handler(data));\n    })\n      .then((result) => {\n        if (!result) {\n          return this._channel.postMessage({ topic: RESPONSE, id });\n        }\n        const transferrables = result[Rpc.transferrables];\n        delete result[Rpc.transferrables];\n        const message = {\n          topic: RESPONSE,\n          id,\n          data: result,\n        };\n        this._channel.postMessage(message, transferrables);\n      })\n      .catch((err) => {\n        const message = {\n          topic: RESPONSE,\n          id,\n          data: {\n            [ERROR]: true,\n            name: err.name,\n            message: err.message,\n            stack: err.stack,\n          },\n        };\n        this._channel.postMessage(message);\n      });\n  };\n\n  // send a message across the rpc boundary to a receiver on the other side\n  // this returns a promise for the receiver's response.  If there is no registered\n  // receiver for the given topic, this method throws\n  send<TResult>(topic: string, data: any, transfer?: any[]): Promise<TResult> {\n    const id = this._messageId++;\n    const message = { topic, id, data };\n    const result = new Promise((resolve, reject) => {\n      this._pendingCallbacks[id] = (info) => {\n        if (info.data && info.data[ERROR]) {\n          const error = new Error(info.data.message);\n          error.name = info.data.name;\n          error.stack = info.data.stack;\n          reject(error);\n        } else {\n          resolve(info.data);\n        }\n      };\n    });\n    this._channel.postMessage(message, transfer);\n    return result;\n  }\n\n  // register a receiver for a given message on a topic\n  // only one receiver can be registered per topic and currently\n  // 'deregistering' a receiver is not supported since this is not common\n  receive<T, TOut>(topic: string, handler: (T) => TOut) {\n    if (this._receivers.has(topic)) {\n      throw new Error(`Receiver already registered for topic: ${topic}`);\n    }\n    this._receivers.set(topic, handler);\n  }\n}\n","// @flow\n//\n//  Copyright (c) 2019-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n/* eslint-disable no-undef */\nexport const inWebWorker = () =>\n  global.postMessage && typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n\nexport const inSharedWorker = () =>\n  typeof SharedWorkerGlobalScope !== \"undefined\" && self instanceof SharedWorkerGlobalScope;\n/* eslint-enable no-undef */\n\nexport const enforceFetchIsBlocked = <R, Args: $ReadOnlyArray<mixed>>(\n  fn: (...args: Args) => R\n): ((...args: Args) => Promise<R>) => {\n  const canFetch =\n    typeof fetch !== \"undefined\" &&\n    fetch(\"data:test\")\n      .then(() => true)\n      .catch(() => false);\n  return async (...args) => {\n    if (await canFetch) {\n      throw new Error(\"Content security policy too loose.\");\n    }\n    return fn(...args);\n  };\n};\n"],"sourceRoot":""}